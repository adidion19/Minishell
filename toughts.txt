
type set for a complete env

a line is divided in sections

each section is delimited by a pipe, or by the end of the line

for each section, we have to define :
	- the input
	- the command - is it a homemade command ? or do we have to look in the path. I will not worry about that for now. just store the name of the command as a string
	- the options
	- the output - ? probably not needed
	- where to send the output

for example : cat test.txt | wc -l
	it has 2 sections

	the first section has : 
		input : "test.txt" as a string
		command : cat
		options : no option
		output : the result of the command cat 
		where to send : to the next section

	the second section had :
		input : what we received from the previous section
		command : wc
		options : l
		output : the result of the command wc
		where to send : the terminal

do we store the sections as a linked list ?
do we store the sections as an array ?

probably better as an array so it's easier to free


array of struct ! --> we need to know how many element we need at first

the parser receives a string.
it decides how many sections are needed
it allocate the right size
then for each section, the parser fill the section struct
at the end the parser return an allocated struct array
the array is null terminated

make a function to free the allocated array. do not forget to free each string inside of struct

export ARG=$(~/generate_random_string_of_number/a.out 100)
echo $ARG






 echo $ARG;  ./push_swap $ARG | wc -l


parser takes a string (the line) and returns a null terminated array of struct



start at the beginning of str.

look only until the pipe

first extract the command name.

then look at the 


a different function for each thing !

find output (the last > , or the default next pipe)
find input (the last < , or the default previoud pipe)
populate the args array

consider the env variables
consider the "" and ''
any quote type cancels the other type inside itself
have a state variable for quote type.
if var is 0 when we find a quote, -> +1 
if var is not 0 when we find a quote -> -1
if we find a quote and the var for the other type is not null, we don't change its state var

still need to manage substitutions (env variables)


substitutions : 

in case of redirection : trim spaces before and after. if any space in between words, error
in case VAR is at the beginning, the first word is a command, and all other words are its arguments
in case there is a command before VAR, all words of VAR are treated as args

there are words : 
words can be interpreted as a command or as an arg. 
that's actually the same thing

words are groups of letters separated by spaces.
a variable substitution is always a word
something inside quotes in always a word.

there are markers : 
markers give special meaning to words following them

we have those markers : < > >> |

marker inside quotes or inside a substitution variable will be treated as a word

inside a pipe section there can be only one command.
it's the first WORD. that's the command.
the position is the only thing that differentiate a command than an arg
the command is the arg[0] that's it



gcc *.c ../utils/*.c

./a.out "           <k >>      > 1>>abc 2d<ef 3>ghi 4j<<kl  5mno 6pqr"
./a.out "<  <g<yopo<rufh>>lolilol>lolk>jkj         <k >>      > 1>>ab>c 2d<ef 3>ghi 4j<<kl  5mno 6pqr"
./a.out "<  <g<yopo<rufh>>lolilol>lolk>jkj         <k >>  '    > 1>>ab>c 2d' <ef 3>ghi' 4j<<kl  5mno 6pqr >>><<<>>> '<  <'<< >> ><u'><>"
